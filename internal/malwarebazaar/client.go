package malwarebazaar

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log/slog"
	"mime"
	"net/http"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	azip "github.com/alexmullins/zip"
)

// DefaultBaseURL is the public MalwareBazaar API endpoint.
const DefaultBaseURL = "https://mb-api.abuse.ch/api/v1/"

const sampleZipPassword = "infected"

var (
	// ErrDisabled is returned when the client is created without a base URL or
	// API key.
	ErrDisabled = errors.New("malwarebazaar client is disabled")
)

// Client is a tiny helper for interacting with MalwareBazaar.
type Client struct {
	BaseURL    string
	APIKey     string
	HTTPClient *http.Client
	Logger     *slog.Logger
}

// FetchByHash retrieves a sample archive for the provided SHA256 hash and
// stores it inside destDir, returning the final path.
func (c *Client) FetchByHash(ctx context.Context, hash, destDir string) (string, error) {
	if strings.TrimSpace(hash) == "" {
		return "", errors.New("hash is required")
	}
	if c == nil || c.BaseURL == "" {
		return "", ErrDisabled
	}
	if destDir == "" {
		destDir = os.TempDir()
	}
	if err := os.MkdirAll(destDir, 0o755); err != nil {
		return "", fmt.Errorf("create destination: %w", err)
	}
	client := c.httpClient()
	form := url.Values{}
	form.Set("query", "get_file")
	form.Set("sha256_hash", hash)
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.BaseURL, strings.NewReader(form.Encode()))
	if err != nil {
		return "", err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	if c.APIKey != "" {
		req.Header.Set("Auth-Key", c.APIKey)
	}
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("malwarebazaar request failed: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return "", fmt.Errorf("malwarebazaar request failed: %s", string(body))
	}
	reader := bufio.NewReader(resp.Body)
	if looksLikeJSON(reader) {
		var failure apiResponse
		if err := json.NewDecoder(reader).Decode(&failure); err != nil {
			return "", fmt.Errorf("decode malwarebazaar response: %w", err)
		}
		if strings.EqualFold(failure.QueryStatus, "ok") && len(failure.Data) > 0 {
			entry := failure.Data[0]
			if entry.ShareableLink != "" {
				return c.downloadFromURL(ctx, entry.ShareableLink, destDir, entry.FileName, hash)
			}
			return "", errors.New("malwarebazaar returned metadata but no shareable link")
		}
		if failure.Message != "" {
			return "", fmt.Errorf("malwarebazaar error: %s", failure.Message)
		}
		return "", fmt.Errorf("malwarebazaar query failed: %s", failure.QueryStatus)
	}
	filename := parseFilename(resp.Header.Get("Content-Disposition"))
	if filename == "" {
		filename = fmt.Sprintf("%s.zip", hash)
	}
	fullPath := filepath.Join(destDir, filename)
	out, err := os.OpenFile(fullPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
	if err != nil {
		return "", fmt.Errorf("create archive: %w", err)
	}
	defer out.Close()
	if _, err := io.Copy(out, reader); err != nil {
		return "", fmt.Errorf("write archive: %w", err)
	}
	extracted, err := extractSampleFromArchive(fullPath, destDir)
	if err != nil {
		return "", err
	}
	return extracted, nil
}

// WatchNewSamples polls MalwareBazaar for new samples and invokes the callback
// for each entry. The callback should return nil when a sample is scheduled,
// and ErrSampleSkipped to indicate a non-fatal skip (duplicates, tag filter,
// etc.). The callback must be fast since it executes sequentially.
func (c *Client) WatchNewSamples(ctx context.Context, interval time.Duration, hours int, callback func(context.Context, SampleSummary) error) error {
	if c == nil || c.BaseURL == "" {
		return ErrDisabled
	}
	if interval <= 0 {
		interval = time.Hour
	}
	ticker := time.NewTicker(interval)
	defer ticker.Stop()
	for {
		total, scheduled, err := c.pullLatest(ctx, hours, callback)
		if err != nil {
			if c.Logger != nil {
				c.Logger.Warn("malwarebazaar poll failed", "error", err)
			}
		} else if c.Logger != nil {
			c.Logger.Info("malwarebazaar poll processed", "results", total, "scheduled", scheduled, "hours", hours)
		}
		select {
		case <-ctx.Done():
			return ctx.Err()
		case <-ticker.C:
		}
	}
}

func (c *Client) pullLatest(ctx context.Context, hours int, callback func(context.Context, SampleSummary) error) (int, int, error) {
	form := url.Values{}
	form.Set("query", "recent_detections")
	if hours > 0 {
		form.Set("hours", strconv.Itoa(hours))
	}
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.BaseURL, strings.NewReader(form.Encode()))
	if err != nil {
		return 0, 0, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	if c.APIKey != "" {
		req.Header.Set("Auth-Key", c.APIKey)
	}
	resp, err := c.httpClient().Do(req)
	if err != nil {
		return 0, 0, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return 0, 0, fmt.Errorf("malwarebazaar responded %s: %s", resp.Status, string(body))
	}
	var data apiResponse
	if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
		return 0, 0, err
	}
	if !strings.EqualFold(data.QueryStatus, "ok") {
		if data.Message != "" {
			return 0, 0, fmt.Errorf("malwarebazaar error: %s", data.Message)
		}
		return 0, 0, fmt.Errorf("malwarebazaar query failed: %s", data.QueryStatus)
	}
	total := len(data.Data)
	processed := 0
	for _, entry := range data.Data {
		c.Logger.Debug("Processing entry", "entry", entry)

		if callback != nil {
			if err := callback(ctx, entry); err != nil {
				if err == ErrSampleSkipped {
					continue
				}
				return total, processed, err
			} else {
				processed++
			}
		}
	}
	return total, processed, nil
}

func (c *Client) httpClient() *http.Client {
	if c.HTTPClient != nil {
		return c.HTTPClient
	}
	return http.DefaultClient
}

func parseFilename(header string) string {
	if header == "" {
		return ""
	}
	_, params, err := mime.ParseMediaType(header)
	if err != nil {
		return ""
	}
	return params["filename"]
}

func looksLikeJSON(r *bufio.Reader) bool {
	peek, err := r.Peek(512)
	if err != nil && err != bufio.ErrBufferFull && err != io.EOF {
		return false
	}
	idx := 0
	if len(peek) >= 3 && peek[0] == 0xEF && peek[1] == 0xBB && peek[2] == 0xBF {
		idx = 3
	}
	for ; idx < len(peek); idx++ {
		switch peek[idx] {
		case ' ', '\t', '\n', '\r':
			continue
		default:
			return isJSONStart(peek[idx])
		}
	}
	return false
}

func isJSONStart(b byte) bool {
	switch b {
	case '{', '[', '"', 't', 'f', 'n', '-', '+', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
		return true
	default:
		return false
	}
}

func (c *Client) downloadFromURL(ctx context.Context, link, destDir, preferredName, hash string) (string, error) {
	if strings.TrimSpace(link) == "" {
		return "", errors.New("download link is empty")
	}
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, link, nil)
	if err != nil {
		return "", err
	}
	resp, err := c.httpClient().Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))
		return "", fmt.Errorf("download failed: %s", string(body))
	}
	filename := parseFilename(resp.Header.Get("Content-Disposition"))
	if filename == "" {
		filename = preferredName
	}
	if filename == "" {
		if parsed, err := url.Parse(link); err == nil {
			filename = path.Base(parsed.Path)
		}
	}
	if filename == "" {
		filename = fmt.Sprintf("%s.zip", hash)
	}
	if err := os.MkdirAll(destDir, 0o755); err != nil {
		return "", err
	}
	fullPath := filepath.Join(destDir, filename)
	out, err := os.OpenFile(fullPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0o644)
	if err != nil {
		return "", err
	}
	if _, err := io.Copy(out, resp.Body); err != nil {
		out.Close()
		return "", err
	}
	if err := out.Close(); err != nil {
		return "", err
	}
	extracted, err := extractSampleFromArchive(fullPath, destDir)
	if err != nil {
		return "", err
	}
	return extracted, nil
}

func extractSampleFromArchive(zipPath, destDir string) (string, error) {
	reader, err := azip.OpenReader(zipPath)
	if err != nil {
		return "", fmt.Errorf("open archive: %w", err)
	}
	defer reader.Close()

	var extracted string
	for _, file := range reader.File {
		if file.FileInfo().IsDir() {
			continue
		}
		if file.IsEncrypted() {
			file.SetPassword(sampleZipPassword)
		}
		name := filepath.Base(file.Name)
		if name == "" {
			continue
		}
		destPath := filepath.Join(destDir, name)
		if err := os.MkdirAll(filepath.Dir(destPath), 0o755); err != nil {
			return "", err
		}
		rc, err := file.Open()
		if err != nil {
			return "", err
		}
		out, err := os.OpenFile(destPath, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, file.Mode())
		if err != nil {
			rc.Close()
			return "", err
		}
		if _, err := io.Copy(out, rc); err != nil {
			out.Close()
			rc.Close()
			return "", err
		}
		if err := out.Close(); err != nil {
			rc.Close()
			return "", err
		}
		rc.Close()
		extracted = destPath
		break
	}
	if extracted == "" {
		return "", errors.New("zip archive contains no files")
	}
	_ = os.Remove(zipPath)
	return extracted, nil
}

// SampleSummary is a subset of the MalwareBazaar response describing a sample.
type SampleSummary struct {
	SHA256        string `json:"sha256_hash"`
	SHA1          string `json:"sha1_hash"`
	MD5           string `json:"md5_hash"`
	FileName      string `json:"file_name"`
	FileType      string `json:"file_type"`
	FileTypeMime  string `json:"file_type_mime"`
	Reporter      string `json:"reporter"`
	FirstSeen     string `json:"first_seen"`
	LastSeen      string `json:"last_seen"`
	FileSize      int64  `json:"file_size"`
	Signature     string `json:"signature"`
	ShareableLink string `json:"shareable_link"`
}

type apiResponse struct {
	QueryStatus string          `json:"query_status"`
	Message     string          `json:"message"`
	Data        []SampleSummary `json:"data"`
}
