package malwarebazaar

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"strings"
	"time"

	"github.com/cochaviz/bottle-warden/internal/analysis"
	"github.com/cochaviz/bottle-warden/internal/appconfig"
)

// Watcher monitors MalwareBazaar for new samples and schedules analyses.
type Watcher struct {
	client       *Client
	ledger       *analysis.Ledger
	orchestrator *analysis.Orchestrator
	cfg          appconfig.MalwareBazaarWatcherConfig
	sampleDir    string
	logger       *slog.Logger
}

// ErrSampleSkipped signals that a sample was intentionally not scheduled (e.g.,
// filtered by tags or already present in the ledger).
var ErrSampleSkipped = errors.New("sample skipped")

// NewWatcher builds a watcher if configuration is valid.
func NewWatcher(client *Client, ledger *analysis.Ledger, orchestrator *analysis.Orchestrator, cfg appconfig.MalwareBazaarWatcherConfig, sampleDir string, logger *slog.Logger) *Watcher {
	if client == nil || ledger == nil {
		return nil
	}
	if !cfg.Enabled {
		return nil
	}
	if logger == nil {
		logger = slog.Default()
	}
	if strings.TrimSpace(sampleDir) == "" {
		sampleDir = "data/samples"
	}
	return &Watcher{
		client:       client,
		ledger:       ledger,
		orchestrator: orchestrator,
		cfg:          cfg,
		sampleDir:    sampleDir,
		logger:       logger.With("component", "malwarebazaar_watcher"),
	}
}

// Run starts the watch loop.
func (w *Watcher) Run(ctx context.Context) error {
	if w == nil {
		<-ctx.Done()
		return ctx.Err()
	}
	w.logger.Info("starting malwarebazaar watcher", "interval", w.cfg.WatchInterval)
	interval := w.cfg.WatchInterval
	if interval <= 0 {
		interval = time.Hour
	}
	return w.client.WatchNewSamples(ctx, interval, w.cfg.LookbackHours, func(cbCtx context.Context, sample SampleSummary) error {
		if err := w.handleSample(cbCtx, sample); err != nil {
			if err == ErrSampleSkipped {
				return err
			}
			w.logger.Warn("failed to schedule malwarebazaar sample", "sha256", sample.SHA256, "error", err)
			return err
		}
		return nil
	})
}

func (w *Watcher) handleSample(ctx context.Context, sample SampleSummary) error {
	if strings.TrimSpace(sample.SHA256) == "" {
		return errors.New("sample sha256 missing")
	}
	if len(w.cfg.Signatures) > 0 && !sampleHasSignature(sample, w.cfg.Signatures) {
		return ErrSampleSkipped
	}
	if w.sampleExists(sample.SHA256) {
		return ErrSampleSkipped
	}
	if err := os.MkdirAll(w.sampleDir, 0o755); err != nil {
		return fmt.Errorf("prepare sample dir: %w", err)
	}
	ctx, cancel := context.WithTimeout(ctx, 2*time.Minute)
	defer cancel()
	path, err := w.client.FetchByHash(ctx, sample.SHA256, w.sampleDir)
	if err != nil {
		return err
	}
	record := analysis.NewRecord(sample.SHA256, analysis.SourceSpec{Type: analysis.SourceHash, Value: sample.SHA256})
	record.SamplePath = path
	record.Instrumentation = w.cfg.Instrumentation
	record.SampleTimeout = analysis.Duration{Duration: w.cfg.SampleTimeout}
	record.SandboxTimeout = analysis.Duration{Duration: w.cfg.SandboxTimeout}
	record.Metadata = map[string]string{
		"source":                    "malwarebazaar",
		"malwarebazaar_sha256":      sample.SHA256,
		"malwarebazaar_file_name":   sample.FileName,
		"malwarebazaar_signature":   sample.Signature,
		"malwarebazaar_shareable":   sample.ShareableLink,
		"malwarebazaar_first_seen":  sample.FirstSeen,
		"malwarebazaar_last_seen":   sample.LastSeen,
		"malwarebazaar_reporter":    sample.Reporter,
		"malwarebazaar_file_type":   sample.FileType,
		"malwarebazaar_hash_md5":    sample.MD5,
		"malwarebazaar_hash_sha1":   sample.SHA1,
		"malwarebazaar_file_source": sample.FileTypeMime,
	}
	rec, err := w.ledger.Create(record)
	if err != nil {
		return err
	}
	w.logger.Info("scheduled malwarebazaar sample", "id", rec.ID, "sha256", sample.SHA256, "path", path)
	if w.orchestrator != nil {
		w.orchestrator.Trigger()
	}
	return nil
}

func (w *Watcher) sampleExists(sampleID string) bool {
	for _, rec := range w.ledger.List() {
		if strings.EqualFold(rec.SampleID, sampleID) {
			return true
		}
	}
	return false
}

func sampleHasSignature(sample SampleSummary, signatures []string) bool {
	sig := strings.ToLower(strings.TrimSpace(sample.Signature))
	if sig == "" {
		return false
	}
	for _, target := range signatures {
		if sig == target {
			return true
		}
	}
	return false
}
